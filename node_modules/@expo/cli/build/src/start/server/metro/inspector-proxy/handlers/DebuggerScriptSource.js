"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
var _fs = _interopRequireDefault(require("fs"));
var _nodeFetch = _interopRequireDefault(require("node-fetch"));
var _path = _interopRequireDefault(require("path"));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
class DebuggerScriptSourceHandler {
    constructor(device){
        this.device = device;
    }
    onDebuggerMessage(message, { socket  }) {
        // See: https://github.com/facebook/metro/blob/65d801cb60c06c1b17f428ca79491db73c53ef87/packages/metro-inspector-proxy/src/Device.js#L488-L544
        if (message.method === "Debugger.getScriptSource") {
            const { scriptId  } = message.params;
            const pathOrUrl = this.device._scriptIdToSourcePathMapping.get(scriptId);
            // Unkown scriptId provided, can't reply
            if (!pathOrUrl) {
                return false;
            }
            // Fetch the source from URL, if the path is a bundle URL
            if (isUrl(pathOrUrl)) {
                (0, _nodeFetch).default(pathOrUrl).then((response)=>response.ok ? response.text() : respond(socket, message, {
                        error: `Received status ${response.status} while fetching: ${pathOrUrl}`
                    })
                ).then((scriptSource)=>{
                    if (scriptSource !== null) {
                        respond(socket, message, {
                            scriptSource
                        });
                    }
                });
                return true;
            }
            // Fetch the source from file directly, using the project root as starting directory
            try {
                const relativePath = _path.default.resolve(this.device._projectRoot, pathOrUrl);
                respond(socket, message, {
                    scriptSource: _fs.default.readFileSync(relativePath, "utf8")
                });
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                respond(socket, message, {
                    error: `Failed to load "${pathOrUrl}": ${errorMessage}`
                });
            }
            return true;
        }
        return false;
    }
}
exports.DebuggerScriptSourceHandler = DebuggerScriptSourceHandler;
function respond(socket, request, response) {
    if ("error" in response) {
        socket.send(JSON.stringify({
            id: request.id,
            error: {
                message: response.error
            }
        }));
    } else {
        socket.send(JSON.stringify({
            id: request.id,
            result: response
        }));
    }
    return null;
}
function isUrl(pathOrUrl) {
    try {
        const url = new URL(pathOrUrl);
        return [
            "http",
            "https"
        ].some((protocol)=>url.protocol.toLowerCase().startsWith(protocol)
        );
    } catch  {
        return false;
    }
}

//# sourceMappingURL=DebuggerScriptSource.js.map